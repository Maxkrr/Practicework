# Practicework
## Вариант 2. 
### Реализуйте рекурсивную функцию для вычисления степени числа (power(x, n)).
#### Объяснение алгоритма С++.
Алгоритм функции power в данном коде вычисляет степень числа x в степени n с помощью рекурсии и оптимизации для четных степеней.
Основные шаги работы алгоритма:
1) Функция power(double x, int n) реализует возведение числа x в целую степень n с помощью рекурсии.
2) Конструкция if (n == 0) проверяет базовый случай рекурсии — любая степень 0 равна 1.
3) Далее if (n < 0) обрабатывает отрицательные степени, возвратом обратного значения степени с положительным показателем.
4) Затем условие if (n % 2 == 0) проверяет, чётна ли степень; если да, реализуется оптимизация через возведение в степень половинного значения: xn=(x2)n/2xn=(x2)n/2.
5) Если степень нечётная, возвращается произведение основания x на рекурсивный вызов степени n−1.
Таким образом, алгоритм реализован с помощью рекурсии и оптимизации для более быстрого возведения в степень, особенно при больших степенях.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
#### Объяснение алгоритма Python.
1) Функция power(x, n) реализует рекурсивный алгоритм возведения числа x в целую степень n.
2) Базовый случай if n == 0: return 1.0 означает, что любое число в степени 0 равно 1.
3) Условие if n < 0: обрабатывает отрицательные степени, возвращая обратное значение степени с положительным показателем.
4) Проверка if n % 2 == 0: использует оптимизацию для чётных степеней, уменьшая количество умножений за счёт формулы xn=(x2)n/2xn=(x2)n/2.
5) В случае нечётной степени возвращается произведение x на рекурсивный вызов с степенью n-1.
6) Оператор return возвращает результат вычисления на каждом шаге рекурсии.
7) Оператор // — целочисленное деление в Python, применяется для правильного деления показателя степени на 2.
8) В конце пример использования функции через print, который форматирует строку с результатом.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Такая сложность обусловлена тем, что при чётных степенях показатель делится пополам, что уменьшает число рекурсивных вызовов до логарифмического количества относительно n.
#### Объяснение алгоритма Java.
1) Метод power(double x, int n) рекурсивно вычисляет число x в степени n.
2) Условие if (n == 0) возвращает 1.0 — базовый случай рекурсии, так как любое число в нулевой степени равно 1.
3) Если степень отрицательная (if (n < 0)), вычисляется обратное значение степени с положительным показателем.
4) Для чётных степеней (if (n % 2 == 0)) используется оптимизация: xn=(x2)n/2xn=(x2)n/2, уменьшая количество рекурсивных вызовов.
5) Если степень нечётная, функция возвращает произведение x на рекурсивный вызов степени n−1n−1.
6) В методе main создаются переменные для основания и степени, вызывается power, и результат выводится на экран через System.out.println.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Такая сложность достигается за счет того, что при четной степени показатель степени делится на 2 в каждом рекурсивном вызове, что сокращает количество умножений с линейного до логарифмического относительно n.
### Вопрос 10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
Обход дерева в глубину (DFS) и в ширину (BFS) различаются по способу посещения узлов:
1) DFS (поиск в глубину) исследует ветви дерева, углубляясь туда, пока не достигнет конца ветви, затем возвращается назад для обхода других путей. Он использует стек (явно или через рекурсию) для запоминания состояния. DFS идет по глубине дерева, то есть сначала посещает глубже лежащие узлы.
2) BFS (поиск в ширину) исследует дерево по уровням, посещая сначала все узлы одного уровня, затем переходя к следующему. BFS использует очередь для хранения узлов текущего уровня. Таким образом, он расширяется в ширину или "птичьим взглядом".

Временная сложность обоих алгоритмов — O(V+E)O(V+E), где VV — количество узлов, EE — количество рёбер. Таким образом, DFS исследует дерево углубляясь в ветви, используя стек, а BFS — по уровням, используя очередь, что влияет на их применение и поведение при обходе графов и деревьев.
