# Practicework
## Вариант 2. 
### Реализуйте рекурсивную функцию для вычисления степени числа (power(x, n)).
#### Объяснение алгоритма С++.
Алгоритм функции power в данном коде вычисляет степень числа x в степени n с помощью рекурсии и оптимизации для четных степеней.
Основные шаги работы алгоритма:
1) Функция power(double x, int n) реализует возведение числа x в целую степень n с помощью рекурсии.
2) Конструкция if (n == 0) проверяет базовый случай рекурсии — любая степень 0 равна 1.
3) Далее if (n < 0) обрабатывает отрицательные степени, возвратом обратного значения степени с положительным показателем.
4) Затем условие if (n % 2 == 0) проверяет, чётна ли степень; если да, реализуется оптимизация через возведение в степень половинного значения: xn=(x2)n/2xn=(x2)n/2.
5) Если степень нечётная, возвращается произведение основания x на рекурсивный вызов степени n−1.
Таким образом, алгоритм реализован с помощью рекурсии и оптимизации для более быстрого возведения в степень, особенно при больших степенях.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
#### Объяснение алгоритма Python.

#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
#### Объяснение алгоритма Java.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
### Вопрос 10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
