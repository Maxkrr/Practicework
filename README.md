# Practicework
## Вариант 2. 
### Реализуйте рекурсивную функцию для вычисления степени числа (power(x, n)).
#### Объяснение алгоритма С++.
Алгоритм функции power в данном коде вычисляет степень числа x в степени n с помощью рекурсии и оптимизации для четных степеней.
Основные шаги работы алгоритма:
1) Функция power(double x, int n) реализует возведение числа x в целую степень n с помощью рекурсии.
2) Конструкция if (n == 0) проверяет базовый случай рекурсии — любая степень 0 равна 1.
3) Далее if (n < 0) обрабатывает отрицательные степени, возвратом обратного значения степени с положительным показателем.
4) Затем условие if (n % 2 == 0) проверяет, чётна ли степень; если да, реализуется оптимизация через возведение в степень половинного значения: xn=(x2)n/2xn=(x2)n/2.
5) Если степень нечётная, возвращается произведение основания x на рекурсивный вызов степени n−1.
Таким образом, алгоритм реализован с помощью рекурсии и оптимизации для более быстрого возведения в степень, особенно при больших степенях.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
#### Объяснение алгоритма Python.
1) Функция power(x, n) реализует рекурсивный алгоритм возведения числа x в целую степень n.
2) Базовый случай if n == 0: return 1.0 означает, что любое число в степени 0 равно 1.
3) Условие if n < 0: обрабатывает отрицательные степени, возвращая обратное значение степени с положительным показателем.
4) Проверка if n % 2 == 0: использует оптимизацию для чётных степеней, уменьшая количество умножений за счёт формулы xn=(x2)n/2xn=(x2)n/2.
5) В случае нечётной степени возвращается произведение x на рекурсивный вызов с степенью n-1.
6) Оператор return возвращает результат вычисления на каждом шаге рекурсии.
7) Оператор // — целочисленное деление в Python, применяется для правильного деления показателя степени на 2.
8) В конце пример использования функции через print, который форматирует строку с результатом.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Такая сложность обусловлена тем, что при чётных степенях показатель делится пополам, что уменьшает число рекурсивных вызовов до логарифмического количества относительно n.
#### Объяснение алгоритма Java.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
### Вопрос 10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
