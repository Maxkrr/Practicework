# Practicework
## Вариант 2. 
### Реализуйте рекурсивную функцию для вычисления степени числа (power(x, n)).
#### Объяснение алгоритма С++.
Алгоритм функции power в данном коде вычисляет степень числа x в степени n с помощью рекурсии и оптимизации для четных степеней.
Основные шаги работы алгоритма:
1) Если степень n равна 0, возвращается 1 (базовый случай, так как любое число в степени 0 равно 1).
2) Если степень отрицательная, функция вызывает сама себя с положительной степенью -n и возвращает обратное число 1/power(x, -n).
3) Если степень чётная, используется рекурсивный вызов для возведения x*x в степень n/2, что сокращает количество операций (x^(2k) = (x^2)^k).
4) Если степень нечётная, результатом будет x, умноженное на рекурсивно вычисленное power(x, n-1).
Таким образом, алгоритм реализован с помощью рекурсии и оптимизации для более быстрого возведения в степень, особенно при больших степенях.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
#### Объяснение алгоритма Python.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
#### Объяснение алгоритма Java.
#### Временная сложность.
Временная сложность алгоритма — O(log⁡n), где n — показатель степени.
#### Объяснение временной сложности.
Алгоритм использует двоичное представление степени и свойства возведения в квадрат для уменьшения количества умножений, что даёт временную сложность O(log⁡n).
### Вопрос 10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
